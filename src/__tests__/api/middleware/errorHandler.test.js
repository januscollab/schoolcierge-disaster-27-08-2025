/**
 * Unit tests for src/api/middleware/errorHandler.js
 * Generated by Test Enhancer
 */

describe('errorHandler Middleware Tests', () => {
  let middleware;
  let req, res, next;

  beforeEach(() => {
    // Mock the logger module
    jest.mock('../../../api/utils/logger', () => ({
      error: jest.fn(),
      warn: jest.fn(),
      info: jest.fn(),
      debug: jest.fn()
    }));
    
    // Mock Express request, response, and next
    req = {
      headers: {},
      body: {},
      query: {},
      params: {},
      user: null,
      url: '/test',
      method: 'GET'
    };
    
    res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn().mockReturnThis(),
      send: jest.fn().mockReturnThis(),
      set: jest.fn().mockReturnThis()
    };
    
    next = jest.fn();
    
    // Clear module cache to get fresh instance
    jest.resetModules();
    middleware = require('../../../api/middleware/errorHandler.js');
  });

  test('should be a function', () => {
    expect(typeof middleware).toBe('function');
  });

  test('should handle error and return JSON response', () => {
    const error = new Error('Test error');
    error.statusCode = 400;
    
    middleware(error, req, res, next);
    
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.json).toHaveBeenCalledWith(expect.objectContaining({
      error: expect.objectContaining({
        message: 'Test error',
        status: 400
      })
    }));
  });

  test('should handle error without statusCode', () => {
    const error = new Error('Internal error');
    
    middleware(error, req, res, next);
    
    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.json).toHaveBeenCalledWith(expect.objectContaining({
      error: expect.objectContaining({
        message: 'Internal error',
        status: 500
      })
    }));
  });

  test('should handle errors gracefully', () => {
    const error = new Error('Test error');
    
    // Even with malformed req, should not throw
    expect(() => {
      middleware(error, {}, res, next);
    }).not.toThrow();
    
    expect(res.status).toHaveBeenCalled();
    expect(res.json).toHaveBeenCalled();
  });

  describe('Security Checks', () => {
    test('should include stack trace in development mode', () => {
      const originalEnv = process.env.NODE_ENV;
      process.env.NODE_ENV = 'development';
      
      const error = new Error('Dev error');
      error.stack = 'Error stack trace';
      
      middleware(error, req, res, next);
      
      expect(res.json).toHaveBeenCalledWith(expect.objectContaining({
        error: expect.objectContaining({
          stack: 'Error stack trace'
        })
      }));
      
      process.env.NODE_ENV = originalEnv;
    });

    test('should not include stack trace in production mode', () => {
      const originalEnv = process.env.NODE_ENV;
      process.env.NODE_ENV = 'production';
      
      const error = new Error('Prod error');
      error.stack = 'Error stack trace';
      
      middleware(error, req, res, next);
      
      const jsonCall = res.json.mock.calls[0][0];
      expect(jsonCall.error.stack).toBeUndefined();
      
      process.env.NODE_ENV = originalEnv;
    });
  });
});
