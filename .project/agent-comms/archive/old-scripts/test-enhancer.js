#!/usr/bin/env node

/**
 * Test Coverage Enhancer for SchoolCierge
 * Automatically generates and manages multi-layer tests
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const ora = require('ora');
const chalk = require('chalk');

class TestEnhancer {
  constructor() {
    this.projectRoot = path.join(__dirname, '../../');
    this.testTypes = {
      unit: { tool: 'jest', extension: '.test.js' },
      integration: { tool: 'supertest', extension: '.integration.test.js' },
      e2e: { tool: 'playwright', extension: '.e2e.test.ts' },
      performance: { tool: 'k6', extension: '.perf.js' },
      security: { tool: 'security-tests', extension: '.security.test.js' }
    };
  }

  async analyze() {
    console.log(chalk.cyan('\nðŸ” Analyzing codebase for test opportunities...\n'));
    
    const analysis = {
      totalFiles: 0,
      testedFiles: 0,
      untested: [],
      coverage: {},
      recommendations: []
    };

    // Analyze API routes
    const apiRoutes = this.findFiles('src/api/routes', '.js');
    apiRoutes.forEach(file => {
      const testFile = this.getTestFile(file, 'integration');
      if (!fs.existsSync(testFile)) {
        analysis.untested.push({ file, type: 'API Route', recommended: 'integration' });
      }
    });

    // Analyze middleware
    const middleware = this.findFiles('src/api/middleware', '.js');
    middleware.forEach(file => {
      const testFile = this.getTestFile(file, 'unit');
      if (!fs.existsSync(testFile)) {
        analysis.untested.push({ file, type: 'Middleware', recommended: 'unit' });
      }
    });

    // Analyze utilities
    const utils = this.findFiles('src/api/utils', '.js');
    utils.forEach(file => {
      const testFile = this.getTestFile(file, 'unit');
      if (!fs.existsSync(testFile)) {
        analysis.untested.push({ file, type: 'Utility', recommended: 'unit' });
      }
    });

    // Analyze scripts
    const scripts = this.findFiles('.project/scripts', '.js');
    scripts.forEach(file => {
      if (!file.includes('test') && !file.includes('.test.')) {
        const testFile = this.getTestFile(file, 'unit');
        if (!fs.existsSync(testFile)) {
          analysis.untested.push({ file, type: 'Script', recommended: 'unit' });
        }
      }
    });

    return analysis;
  }

  findFiles(dir, extension) {
    const files = [];
    const fullPath = path.join(this.projectRoot, dir);
    
    if (!fs.existsSync(fullPath)) return files;
    
    const items = fs.readdirSync(fullPath);
    items.forEach(item => {
      const itemPath = path.join(fullPath, item);
      const stat = fs.statSync(itemPath);
      
      if (stat.isDirectory() && !item.startsWith('.') && item !== 'node_modules') {
        files.push(...this.findFiles(path.join(dir, item), extension));
      } else if (item.endsWith(extension)) {
        files.push(path.join(dir, item));
      }
    });
    
    return files;
  }

  getTestFile(sourceFile, testType) {
    const type = this.testTypes[testType];
    const testDir = sourceFile.replace('src/', 'src/__tests__/');
    const dir = path.dirname(testDir);
    const basename = path.basename(sourceFile, path.extname(sourceFile));
    return path.join(this.projectRoot, dir, basename + type.extension);
  }

  async generateTest(file, testType) {
    const fullPath = path.join(this.projectRoot, file);
    const testFile = this.getTestFile(file, testType);
    const testDir = path.dirname(testFile);

    // Create test directory if it doesn't exist
    if (!fs.existsSync(testDir)) {
      fs.mkdirSync(testDir, { recursive: true });
    }

    // Read source file to understand structure
    const sourceCode = fs.readFileSync(fullPath, 'utf8');
    const hasExports = sourceCode.includes('module.exports') || sourceCode.includes('export');
    const isRoute = file.includes('routes');
    const isMiddleware = file.includes('middleware');
    const isUtil = file.includes('utils');

    let testContent = '';

    if (testType === 'integration' && isRoute) {
      testContent = this.generateIntegrationTest(file, sourceCode);
    } else if (testType === 'unit' && isMiddleware) {
      testContent = this.generateMiddlewareTest(file, sourceCode);
    } else if (testType === 'unit' && isUtil) {
      testContent = this.generateUtilTest(file, sourceCode);
    } else if (testType === 'e2e') {
      testContent = this.generateE2ETest(file);
    } else {
      testContent = this.generateGenericTest(file, testType);
    }

    fs.writeFileSync(testFile, testContent);
    return testFile;
  }

  generateIntegrationTest(file, sourceCode) {
    const basename = path.basename(file, '.js');
    
    return `/**
 * Integration tests for ${file}
 * Generated by Test Enhancer
 */

const request = require('supertest');
const express = require('express');
const path = require('path');

describe('${basename} Integration Tests', () => {
  let app;
  
  beforeAll(() => {
    app = express();
    app.use(express.json());
    
    // Import the route
    const router = require('${path.relative(path.dirname(this.getTestFile(file, 'integration')), path.join(this.projectRoot, file))}');
    app.use('/api', router);
  });

  describe('GET endpoints', () => {
    test('should handle valid requests', async () => {
      const response = await request(app)
        .get('/api/${basename}')
        .expect('Content-Type', /json/);
      
      expect(response.status).toBeLessThanOrEqual(500);
    });

    test('should handle invalid parameters', async () => {
      const response = await request(app)
        .get('/api/${basename}/invalid')
        .expect('Content-Type', /json/);
      
      expect(response.status).toBeLessThanOrEqual(500);
    });
  });

  describe('POST endpoints', () => {
    test('should validate request body', async () => {
      const response = await request(app)
        .post('/api/${basename}')
        .send({})
        .expect('Content-Type', /json/);
      
      expect(response.status).toBeLessThanOrEqual(500);
    });

    test('should handle valid data', async () => {
      const validData = {
        // Add valid test data based on route requirements
        test: true
      };

      const response = await request(app)
        .post('/api/${basename}')
        .send(validData)
        .expect('Content-Type', /json/);
      
      expect(response.status).toBeLessThanOrEqual(500);
    });
  });

  describe('Security', () => {
    test('should prevent SQL injection', async () => {
      const maliciousInput = "'; DROP TABLE users; --";
      
      const response = await request(app)
        .get(\`/api/${basename}?id=\${maliciousInput}\`);
      
      expect(response.status).not.toBe(500);
    });

    test('should prevent XSS attacks', async () => {
      const xssPayload = '<script>alert("XSS")</script>';
      
      const response = await request(app)
        .post('/api/${basename}')
        .send({ data: xssPayload });
      
      if (response.text) {
        expect(response.text).not.toContain('<script>');
      }
    });
  });
});
`;
  }

  generateMiddlewareTest(file, sourceCode) {
    const basename = path.basename(file, '.js');
    
    return `/**
 * Unit tests for ${file}
 * Generated by Test Enhancer
 */

describe('${basename} Middleware Tests', () => {
  let middleware;
  let req, res, next;

  beforeEach(() => {
    // Mock Express request, response, and next
    req = {
      headers: {},
      body: {},
      query: {},
      params: {},
      user: null
    };
    
    res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn().mockReturnThis(),
      send: jest.fn().mockReturnThis(),
      set: jest.fn().mockReturnThis()
    };
    
    next = jest.fn();
    
    // Clear module cache to get fresh instance
    jest.resetModules();
    middleware = require('${path.relative(path.dirname(this.getTestFile(file, 'unit')), path.join(this.projectRoot, file))}');
  });

  test('should be a function', () => {
    expect(typeof middleware).toBe('function');
  });

  test('should call next() for valid requests', () => {
    middleware(req, res, next);
    expect(next).toHaveBeenCalled();
  });

  test('should handle missing headers', () => {
    delete req.headers;
    middleware(req, res, next);
    
    // Should either call next or send error response
    expect(next.mock.calls.length + res.status.mock.calls.length).toBeGreaterThan(0);
  });

  test('should handle errors gracefully', () => {
    req = null; // Force an error
    
    expect(() => {
      middleware(req, res, next);
    }).not.toThrow();
  });

  describe('Security Checks', () => {
    test('should sanitize inputs', () => {
      req.body = { data: '<script>alert("xss")</script>' };
      middleware(req, res, next);
      
      if (req.body.data) {
        expect(req.body.data).not.toContain('<script>');
      }
    });

    test('should validate content types', () => {
      req.headers['content-type'] = 'text/plain';
      middleware(req, res, next);
      
      // Should handle non-JSON content types appropriately
      expect(res.status.mock.calls.length + next.mock.calls.length).toBeGreaterThan(0);
    });
  });
});
`;
  }

  generateUtilTest(file, sourceCode) {
    const basename = path.basename(file, '.js');
    const functions = this.extractFunctions(sourceCode);
    
    return `/**
 * Unit tests for ${file}
 * Generated by Test Enhancer
 */

const utils = require('${path.relative(path.dirname(this.getTestFile(file, 'unit')), path.join(this.projectRoot, file))}');

describe('${basename} Utility Tests', () => {
  ${functions.map(func => `
  describe('${func}', () => {
    test('should be defined', () => {
      expect(utils.${func}).toBeDefined();
    });

    test('should handle valid inputs', () => {
      // Add specific test based on function purpose
      const result = utils.${func}();
      expect(result).toBeDefined();
    });

    test('should handle invalid inputs', () => {
      const invalidInputs = [null, undefined, '', [], {}];
      
      invalidInputs.forEach(input => {
        expect(() => {
          utils.${func}(input);
        }).not.toThrow();
      });
    });

    test('should return expected type', () => {
      const result = utils.${func}();
      // Adjust expectation based on function
      expect(result).toBeDefined();
    });
  });`).join('\n')}

  describe('Edge Cases', () => {
    test('should handle empty inputs', () => {
      ${functions.map(func => `
      expect(() => utils.${func}()).not.toThrow();`).join('')}
    });

    test('should handle large inputs', () => {
      const largeInput = 'x'.repeat(10000);
      ${functions.map(func => `
      expect(() => utils.${func}(largeInput)).not.toThrow();`).join('')}
    });
  });
});
`;
  }

  generateE2ETest(file) {
    return `/**
 * E2E tests for ${file}
 * Generated by Test Enhancer
 */

import { test, expect } from '@playwright/test';

test.describe('${path.basename(file, '.js')} E2E Tests', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('http://localhost:3000');
  });

  test('should load without errors', async ({ page }) => {
    const errors = [];
    page.on('pageerror', error => errors.push(error));
    
    await page.waitForTimeout(1000);
    expect(errors).toHaveLength(0);
  });

  test('should be responsive', async ({ page }) => {
    // Test mobile view
    await page.setViewportSize({ width: 375, height: 667 });
    await expect(page).toHaveScreenshot('mobile.png');
    
    // Test tablet view
    await page.setViewportSize({ width: 768, height: 1024 });
    await expect(page).toHaveScreenshot('tablet.png');
    
    // Test desktop view
    await page.setViewportSize({ width: 1920, height: 1080 });
    await expect(page).toHaveScreenshot('desktop.png');
  });

  test('should handle user interactions', async ({ page }) => {
    // Add specific interaction tests based on the component
    const buttons = await page.$$('button');
    for (const button of buttons) {
      const isEnabled = await button.isEnabled();
      if (isEnabled) {
        await button.click();
        // Verify no errors occurred
        await page.waitForTimeout(100);
      }
    }
  });

  test('should meet accessibility standards', async ({ page }) => {
    const accessibilitySnapshot = await page.accessibility.snapshot();
    expect(accessibilitySnapshot).toBeDefined();
    
    // Check for ARIA labels
    const elements = await page.$$('[aria-label]');
    expect(elements.length).toBeGreaterThan(0);
  });
});
`;
  }

  generateGenericTest(file, testType) {
    const basename = path.basename(file, '.js');
    
    return `/**
 * ${testType} tests for ${file}
 * Generated by Test Enhancer
 */

describe('${basename} Tests', () => {
  beforeAll(() => {
    // Setup
  });

  afterAll(() => {
    // Cleanup
  });

  test('should exist', () => {
    const module = require('${path.relative(path.dirname(this.getTestFile(file, testType)), path.join(this.projectRoot, file))}');
    expect(module).toBeDefined();
  });

  test('should handle basic functionality', () => {
    // Add specific tests based on module purpose
    expect(true).toBe(true);
  });

  describe('Error Handling', () => {
    test('should handle errors gracefully', () => {
      expect(() => {
        // Test error conditions
      }).not.toThrow();
    });
  });

  describe('Performance', () => {
    test('should complete within acceptable time', () => {
      const start = Date.now();
      // Perform operation
      const duration = Date.now() - start;
      expect(duration).toBeLessThan(1000); // 1 second max
    });
  });
});
`;
  }

  extractFunctions(sourceCode) {
    const functions = [];
    
    // Extract function declarations
    const funcMatches = sourceCode.matchAll(/function\s+(\w+)/g);
    for (const match of funcMatches) {
      functions.push(match[1]);
    }
    
    // Extract arrow functions assigned to exports
    const arrowMatches = sourceCode.matchAll(/exports\.(\w+)\s*=/g);
    for (const match of arrowMatches) {
      functions.push(match[1]);
    }
    
    // Extract from module.exports object
    const moduleMatch = sourceCode.match(/module\.exports\s*=\s*{([^}]+)}/);
    if (moduleMatch) {
      const exports = moduleMatch[1].split(',');
      exports.forEach(exp => {
        const name = exp.trim().split(':')[0].trim();
        if (name && !functions.includes(name)) {
          functions.push(name);
        }
      });
    }
    
    return functions.length > 0 ? functions : ['defaultFunction'];
  }

  async generateBatch(files, limit = 10) {
    const spinner = ora('Generating tests...').start();
    const generated = [];
    
    for (let i = 0; i < Math.min(files.length, limit); i++) {
      const { file, recommended } = files[i];
      spinner.text = `Generating ${recommended} test for ${file}...`;
      
      try {
        const testFile = await this.generateTest(file, recommended);
        generated.push({ source: file, test: testFile, type: recommended });
        spinner.text = chalk.green(`âœ“ Generated test for ${file}`);
      } catch (error) {
        spinner.text = chalk.red(`âœ— Failed to generate test for ${file}: ${error.message}`);
      }
    }
    
    spinner.succeed(`Generated ${generated.length} test files`);
    return generated;
  }

  async runTests() {
    console.log(chalk.cyan('\nðŸ§ª Running all tests...\n'));
    
    const testCommands = [
      { name: 'Unit & Integration Tests', cmd: 'npx jest --coverage' },
      { name: 'E2E Tests', cmd: 'npx playwright test' }
    ];
    
    for (const { name, cmd } of testCommands) {
      console.log(chalk.yellow(`Running ${name}...`));
      try {
        const output = execSync(cmd, { encoding: 'utf8', stdio: 'pipe' });
        console.log(chalk.green(`âœ“ ${name} passed`));
      } catch (error) {
        console.log(chalk.red(`âœ— ${name} failed`));
      }
    }
  }

  async generateReport(analysis, generated) {
    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        totalFiles: analysis.untested.length + generated.length,
        testsGenerated: generated.length,
        remainingUntested: analysis.untested.length - generated.length,
        coverageEstimate: Math.round((generated.length / (analysis.untested.length || 1)) * 100)
      },
      generated,
      remaining: analysis.untested.slice(generated.length),
      recommendations: [
        'Run tests regularly with: npm test',
        'Monitor coverage with: npm run test:coverage',
        'Add pre-commit hooks to run tests',
        'Set coverage thresholds in jest.config.js',
        'Implement continuous testing in CI/CD'
      ]
    };
    
    console.log(chalk.cyan('\nðŸ“Š Test Enhancement Report\n'));
    console.log(chalk.white('Summary:'));
    console.log(`  â€¢ Tests Generated: ${chalk.green(report.summary.testsGenerated)}`);
    console.log(`  â€¢ Coverage Increase: ${chalk.green(report.summary.coverageEstimate + '%')}`);
    console.log(`  â€¢ Files Remaining: ${chalk.yellow(report.summary.remainingUntested)}`);
    
    console.log(chalk.white('\nðŸŽ¯ Next Steps:'));
    report.recommendations.forEach((rec, i) => {
      console.log(`  ${i + 1}. ${rec}`);
    });
    
    // Save report
    const reportPath = path.join(this.projectRoot, '.project/test-enhancement-report.json');
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
    console.log(chalk.gray(`\nFull report saved to: ${reportPath}`));
    
    return report;
  }
}

// CLI interface
async function main() {
  const enhancer = new TestEnhancer();
  const args = process.argv.slice(2);
  const command = args[0];
  
  console.log(chalk.cyan.bold('\nðŸš€ SchoolCierge Test Coverage Enhancer\n'));
  
  if (command === 'analyze') {
    const analysis = await enhancer.analyze();
    console.log(chalk.white('Untested Files Found: ') + chalk.red(analysis.untested.length));
    analysis.untested.forEach(({ file, type, recommended }) => {
      console.log(`  â€¢ ${chalk.yellow(file)} (${type}) â†’ ${chalk.green(recommended)}`);
    });
  } else if (command === 'generate') {
    const limit = parseInt(args[1]) || 10;
    const analysis = await enhancer.analyze();
    
    if (analysis.untested.length === 0) {
      console.log(chalk.green('âœ“ All files have tests!'));
      return;
    }
    
    console.log(chalk.yellow(`Found ${analysis.untested.length} untested files`));
    const generated = await enhancer.generateBatch(analysis.untested, limit);
    await enhancer.generateReport(analysis, generated);
    
    // Run the new tests
    const runTests = args.includes('--run');
    if (runTests) {
      await enhancer.runTests();
    }
  } else if (command === 'run') {
    await enhancer.runTests();
  } else {
    console.log('Usage:');
    console.log('  node test-enhancer.js analyze        - Analyze test coverage');
    console.log('  node test-enhancer.js generate [N]   - Generate N tests (default: 10)');
    console.log('  node test-enhancer.js generate --run - Generate and run tests');
    console.log('  node test-enhancer.js run           - Run all tests');
  }
}

if (require.main === module) {
  main().catch(error => {
    console.error(chalk.red('Error:'), error.message);
    process.exit(1);
  });
}

module.exports = TestEnhancer;